+ A **protocol** is a set of rules used to coordinate a communication
	+ It can be seen as a **distributed algorithm**
+ A **Security** or **Cryptographic Protocol** can be used to achieve the various security objectives necessary
+ The messages may use various components and operations:
	+ Names
	+ Keys: $K$ and $K^{-1}$ 
	+ Symmetric Keys
	+ Encryption: Encrypting with public key
	+ Signing: Encrypting with private key
	+ Nonces: Fresh data used for answers
	+ Timestamps
	+ Message Concatenation
---
+ Let's take for example some **remote car keys**	
+ We have to make sure that the car is opened only if the keys send a message to the radio receiver in the car
+ We could use a secret code! But if an attacker catches it and **replays** it to the radio receiver, the system won't work (Replay attack)
+ Even encrypting the code won't work
+ We could instead put a **timestamp** on the message, and make it so that the message is accepted only if the message is recent (Property of **Freshness**)
	+ This is in of itself a great idea, but needs synchronized clocks on both of the systems
+ Another idea is first sending a hi message, the system then replies with a challenge, in this case a nonce, to be met
	+ The idea is good, and cheaper, but needs additional steps in the conversation
---
+ The **Protocol Notation** (Alice and Bob Notation) Is used to describe the communication between principals in protocols
+ In it, the two communicating principals are usually called **Initiator** and **Responder** (or Alice and Bob)
---
+ In the following protocols, the following **assumptions** are considered true:
	+ Principals know their private keys and public keys of others
	+ Principals can generate/check nonces and timestamps, encrypt and decrypt with known keys
	+ Principals correctly implement the protocol (Honest) 
+ The **goals** of the protocols may vary
	+ Authenticate messages, binding them to their originator
	+ Ensure timeliness of messages (recent, fresh, etc)
	+ Guarantee secrecy of certain items (e.g., generated keys)
+ How do we model the **attacker**?
	+ He knows the protocol but cannot break cryptography?
	+ He is **passive** but overhears all communications?
	+ He is **active** and can intercept and generate messages?
	+ He might even be one of the principals running the protocol!
+ We will use the **Standard Attacker Model**, or **Dolev-Yao** Model, In which the attacker is active, and:
	+ He can intercept and read all messages.
	+ He can decompose messages into their parts. But cryptography is secure: decryption requires inverse keys
	+ He can build new messages with the different constructors.
	+ He can send messages at any time.
+ It is a very **strong** assumption, and this makes the obtained systems **very secure**
+ The attacker itself can apply various kinds of attacks
	+ Replay Attacks
	+ Man-in-the-middle Attacks (parallel sessions)
	+ Reflection Attacks
	+ Type Flaw Attacks
		+ When a message is composed by smaller sub-messages, the attacker could use this, exploiting the possible different ways in which the messages are parsed
---
+ An example of a protocol is the **Key Distribution Scenario
+ Description
	+ Alice (A) and Bob (B) need a shared key to communicate, generated by a Key Distribution Center (KDC)
+ Goal
	+ Share secretly a key
+ Here's how it works:
	1. A sends KDC a message containing the identifiers of A and B, with a nonce
	2. KDC answers with a message made by two sections:
		+ The first one is encrypted with A's public key, and contains the previous message sent by A, with the new session key
		+ The second is encrypted with B's public key, and contains the identifier of A, with the new session key
	3. A sends B the second section of the message
	4. B sends A a nonce, encrypted with the new session key
	5. A send B a function of the nonce, encrypted with the new session key
+ While not bad, this protocol is not safe from replay attacks. The usage of timestamps could improve its security 
---
+ The **Needham-Schroeder Public Key Authentication Protocol** (NSPK) has the goal of mutual authentication
+ It works like this
	1. $A → B : \quad \{A, N_A\}_{K_B}$
	2. $B → A : \quad \{N_A, N_B\}_{K_A}$
	3. $A → B : \quad \{N_B\}_{K_B}$
+ It may be  subject to **man-in-the-middle attacks**, used by attackers to fake their identity
+ A simple **solution** is to **specify** the identity of the **interlocutor** (Lowe's Fix)
	2. $B → A : \{N_A, N_B, B\}_{K_A}$
---
+ The **Otway-Rees Protocol** (ORP) has the goal of providing authenticated key distribution (with key authentication and key freshness) but without entity authentication or key confirmation
+ It works like this
	1. $A → B : \quad I, A, B, \{N_A, I, A, B\}_{K_{AS}}$
	2. $B → S : \quad I, A, B, \{N_A, I, A, B\}_{K_{AS}}, \{N_B, I, A, B\}_{K_{BS}}$
	3. $S → B : \quad I, \{N_A, K_{AB}\}_{K_{AS}}, \{N_B, K_{AB}\}_{K_{BS}}$
	4. $B → A : \quad I, \{N_A, K_{AB}\}_{K_{AS}}$
+ This system can be victim of **type flaw attacks**
	+ If B sends back to A its initial message, A can be fooled into thinking that $K_{AB} = IAB$. Idem with S 
+ A **solution** is to use some few more bits to add some **type information** to the sub-messages
---
+ The **Andrew Secure RPC Protocol** (AS) has the goal to exchange a fresh, authenticated, secret, shared key, between two principals sharing a symmetric key.
	1. $A \to B: \quad A, \{N_A\}_{K_{AB}}$ 
	2. $B \to A: \quad \{N_A + 1, N_B\}_{K_{AB}}$
	3. $A \to B: \quad \{N_B+1\}_{K_{AB}}$
	4. $B \to A: \quad \{K'_{AB}, N'_B\}_{K_{AB}}$
+ Establishes the session key $K'_{AB}$ and the nonce $N'_B$ 
+ It still can be victim of **type flaw attacks**, but only authentication is violated, not secrecy
---
+ The **CA (Denning & Sacco) Protocol** is used to share fresh session keys
	1. $A \to S: \quad A,B$
	2. $S \to A: \quad C_A, C_B$
	3. $A \to B: \quad C_A, C_B, \{\{T_A, K_{AB}\}_{K_A^{-1}}\}_{K_B}$
+ It may be  subject to **man-in-the-middle attacks**
+ The solution is still to specify the principals' identities in the messages